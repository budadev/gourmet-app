<!-- =============================
File: index.html
Purpose: GourmetApp — installable PWA that scans barcodes, stores items in local IndexedDB, supports search, optional lookup via Open Food Facts
How to use:
 1) Save files as shown below (index.html, sw.js, manifest.webmanifest).
 2) Serve over HTTPS (required for camera). Any static host works (Cloudflare Pages, GitHub Pages, Netlify, simple HTTPS server).
 3) On iPhone: open in Safari → Share → Add to Home Screen. First launch will ask for camera permission when scanning.
================================ -->
<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>GourmetApp</title>
    <meta name="theme-color" content="#111827" />
    <meta name="description" content="Barcode scanner and item manager for gourmet products" />

    <!-- iOS-specific meta tags for better PWA support -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-title" content="GourmetApp" />

    <link rel="manifest" href="./manifest.webmanifest" />
    <link rel="apple-touch-icon" href="icons/icon-192.png" />
    <style>
        :root{
            --bg:#f8fafc;
            --bg-secondary:#f1f5f9;
            --card:#ffffff;
            --card-hover:#f8fafc;
            --muted:#64748b;
            --text:#0f172a;
            --text-secondary:#475569;
            --primary:#3b82f6;
            --primary-dark:#2563eb;
            --primary-light:#93c5fd;
            --accent:#10b981;
            --accent-light:#d1fae5;
            --border:#e2e8f0;
            --border-light:#f1f5f9;
            --shadow:0 1px 3px rgba(0,0,0,0.08);
            --shadow-md:0 4px 6px rgba(0,0,0,0.07), 0 2px 4px rgba(0,0,0,0.06);
            --shadow-lg:0 10px 15px rgba(0,0,0,0.1), 0 4px 6px rgba(0,0,0,0.05);
            --shadow-xl:0 20px 25px rgba(0,0,0,0.15), 0 10px 10px rgba(0,0,0,0.04);
        }

        *{box-sizing:border-box}

        html{
            overflow-x:hidden;
            width:100%;
            position:relative;
            /* Handle iOS safe areas (notch/Dynamic Island) */
            padding-top:env(safe-area-inset-top);
            padding-bottom:env(safe-area-inset-bottom);
            padding-left:env(safe-area-inset-left);
            padding-right:env(safe-area-inset-right);
        }

        body{
            margin:0;
            background:linear-gradient(135deg, #f8fafc 0%, #e0f2fe 100%);
            color:var(--text);
            font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,sans-serif;
            min-height:100vh;
            overflow-x:hidden;
            width:100%;
            position:relative;
            overscroll-behavior-x:none;
            /* Additional safe area handling */
            min-height:calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
        }

        header{
            position:sticky;
            top:0;
            background:rgba(255, 255, 255, 0.95);
            backdrop-filter:blur(12px);
            padding:16px 20px;
            border-bottom:1px solid var(--border);
            z-index:100;
            box-shadow:var(--shadow);
            /* Add safe area insets for notch */
            padding-top:calc(16px + env(safe-area-inset-top));
            padding-left:calc(20px + env(safe-area-inset-left));
            padding-right:calc(20px + env(safe-area-inset-right));
        }

        h1{
            margin:0 0 14px 0;
            font-size:24px;
            font-weight:700;
            letter-spacing:-0.5px;
            background:linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            -webkit-background-clip:text;
            -webkit-text-fill-color:transparent;
            background-clip:text;
        }

        main{
            max-width:900px;
            margin:0 auto;
            padding:24px 20px;
            padding-bottom:100px;
        }

        .row{display:flex;gap:10px;flex-wrap:wrap}

        .btn{
            appearance:none;
            border:2px solid var(--border);
            background:var(--card);
            color:var(--text);
            border-radius:12px;
            padding:12px 20px;
            font-weight:600;
            font-size:15px;
            cursor:pointer;
            transition:all 0.2s ease;
            box-shadow:var(--shadow);
        }

        .btn:hover{
            border-color:var(--primary-light);
            transform:translateY(-1px);
            box-shadow:var(--shadow-md);
        }

        .btn.primary{
            background:linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            border-color:var(--primary);
            color:#ffffff;
        }

        .btn.primary:hover{
            transform:translateY(-2px);
            box-shadow:0 8px 16px rgba(59, 130, 246, 0.3);
        }

        .btn:disabled{opacity:0.5;cursor:not-allowed}

        .card{
            background:var(--card);
            border:1px solid var(--border);
            border-radius:16px;
            padding:16px;
            margin-bottom:14px;
            box-shadow:var(--shadow);
        }

        input,select,textarea{
            width:100%;
            background:var(--bg-secondary);
            border:2px solid var(--border);
            border-radius:12px;
            color:var(--text);
            padding:12px 14px;
            font-size:15px;
            transition:all 0.2s ease;
            font-family:inherit;
        }

        input:focus,select:focus,textarea:focus{
            outline:none;
            border-color:var(--primary);
            background:var(--card);
            box-shadow:0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        input::placeholder,textarea::placeholder{
            color:var(--muted);
        }

        label{
            font-size:13px;
            font-weight:600;
            color:var(--text-secondary);
            display:block;
            margin-bottom:6px;
            letter-spacing:0.3px;
        }

        .grid{display:grid;grid-template-columns:1fr;gap:16px}
        @media(min-width:700px){.grid{grid-template-columns:1fr 1fr}}

        .list{display:grid;gap:12px}

        .item{
            background:var(--card);
            border:2px solid var(--border);
            border-radius:16px;
            padding:16px 18px;
            cursor:pointer;
            transition:all 0.2s ease;
            box-shadow:var(--shadow);
        }

        .item:hover{
            border-color:var(--primary-light);
            background:var(--card-hover);
            transform:translateY(-2px);
            box-shadow:var(--shadow-md);
        }

        .item.selected{
            border-color:var(--primary);
            background:var(--accent-light);
            box-shadow:var(--shadow-md);
        }

        .muted{color:var(--muted);font-size:14px}

        video{
            width:100%;
            border-radius:16px;
            background:#000;
            box-shadow:var(--shadow-lg);
        }

        .badge{
            display:inline-block;
            padding:6px 14px;
            border-radius:999px;
            background:var(--accent-light);
            color:var(--accent);
            border:1px solid var(--accent);
            font-size:13px;
            font-weight:700;
        }

        /* Search bar with barcode icon */
        .search-wrapper{position:relative;width:100%}
        .search-wrapper input{padding-right:50px}
        .search-wrapper .barcode-btn{
            position:absolute;
            right:4px;
            top:50%;
            transform:translateY(-50%);
            background:transparent;
            border:none;
            cursor:pointer;
            padding:8px;
            border-radius:10px;
            display:flex;
            align-items:center;
            justify-content:center;
            width:42px;
            height:42px;
            transition:all 0.2s ease;
        }
        .search-wrapper .barcode-btn:hover{
            background:var(--primary-light);
            transform:translateY(-50%) scale(1.05);
        }
        .search-wrapper .barcode-btn img{width:24px;height:24px;opacity:0.8}
        .search-wrapper .barcode-btn:hover img{opacity:1}

        /* Input field with barcode icon */
        .input-with-barcode{position:relative}
        .input-with-barcode input{padding-right:50px}
        .input-with-barcode .barcode-btn{
            position:absolute;
            right:4px;
            top:50%;
            transform:translateY(-50%);
            background:transparent;
            border:none;
            cursor:pointer;
            padding:8px;
            border-radius:10px;
            display:flex;
            align-items:center;
            justify-content:center;
            width:42px;
            height:42px;
            transition:all 0.2s ease;
        }
        .input-with-barcode .barcode-btn:hover{
            background:var(--primary-light);
            transform:translateY(-50%) scale(1.05);
        }
        .input-with-barcode .barcode-btn img{width:24px;height:24px;opacity:0.8}
        .input-with-barcode .barcode-btn:hover img{opacity:1}

        /* Floating add button */
        .fab{
            position:fixed;
            bottom:28px;
            right:28px;
            width:64px;
            height:64px;
            border-radius:50%;
            background:linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            border:none;
            color:#ffffff;
            font-size:32px;
            font-weight:300;
            box-shadow:var(--shadow-xl);
            cursor:pointer;
            display:flex;
            align-items:center;
            justify-content:center;
            z-index:1000;
            transition:all 0.3s ease;
        }
        .fab:hover{
            transform:scale(1.1) rotate(90deg);
            box-shadow:0 25px 35px rgba(59, 130, 246, 0.4);
        }
        .fab:active{transform:scale(0.95) rotate(90deg)}

        /* Modal/overlay styles */
        .modal{
            position:fixed;
            top:0;
            left:0;
            right:0;
            bottom:0;
            background:rgba(0, 0, 0, 0.5);
            backdrop-filter:blur(4px);
            z-index:2000;
            display:none;
            overflow-y:auto;
        }
        .modal.active{display:flex;}
        .modal-content{
            background:var(--card);
            border:none;
            border-radius:0;
            width:100%;
            height:100%;
            display:flex;
            flex-direction:column;
            box-shadow:none;
            /* Replaced slide/transform animation (causes iOS double-tap bug on selects) with fade-only */
            animation:modalFadeIn 0.25s ease-out;
        }

        @keyframes modalFadeIn{
            from{opacity:0;}
            to{opacity:1;}
        }
        /* Removed old modalSlideIn definition usage above */
        /* Add touch-action optimization for interactive form elements to reduce iOS 300ms ghost tap */
        input,select,textarea{touch-action:manipulation;}
        /* Improve select tap highlight removal */
        select{-webkit-tap-highlight-color:transparent;}

        .modal-header{
            display:flex;
            justify-content:space-between;
            align-items:center;
            padding:28px 28px 16px 28px;
            border-bottom:2px solid var(--border-light);
            flex-shrink:0;
        }
        .modal-header h2{
            margin:0;
            font-size:24px;
            font-weight:700;
            color:var(--text);
        }

        .modal-body{
            padding:28px;
            overflow-y:auto;
            flex:1;
            min-height:0;
        }

        .modal-footer{
            padding:16px 28px 28px 28px;
            border-top:2px solid var(--border-light);
            flex-shrink:0;
        }

        /* Scanner modal needs higher z-index to appear above editor */
        #scannerModal{z-index:3000}

        /* Item details */
        .detail-section{margin-top:20px}
        .detail-row{
            display:flex;
            justify-content:space-between;
            margin-bottom:16px;
            padding-bottom:16px;
            border-bottom:1px solid var(--border-light);
            align-items:center;
        }
        .detail-row:last-child{border-bottom:none}
        .detail-label{
            color:var(--text-secondary);
            font-size:13px;
            font-weight:600;
            letter-spacing:0.3px;
            text-transform:uppercase;
        }
        .detail-value{
            font-weight:600;
            color:var(--text);
            text-align:right;
        }

        .empty-state{
            text-align:center;
            padding:60px 20px;
            color:var(--muted);
            font-size:16px;
        }

        /* Star rating */
        .star-rating{display:flex;gap:6px;align-items:center}
        .star{
            font-size:32px;
            cursor:pointer;
            color:#d4d4d8;
            transition:all 0.2s ease;
            user-select:none;
            filter:drop-shadow(0 1px 2px rgba(0,0,0,0.1));
        }
        .star:hover{transform:scale(1.15)}
        .star.filled{color:#fbbf24}
        .star.half{position:relative;color:#d4d4d8}
        .star.half::before{
            content:'★';
            position:absolute;
            left:0;
            top:0;
            color:#fbbf24;
            overflow:hidden;
            width:50%;
        }
        .star-rating-display{display:flex;gap:3px;align-items:center}
        .star-rating-display .star{font-size:22px;cursor:default}

        /* Dynamic fields */
        .field-group{margin-bottom:16px}
        .field-group label{display:block;margin-bottom:6px}

        /* Additional polish */
        ::selection{
            background:var(--primary-light);
            color:var(--text);
        }

        /* Smooth scrollbar */
        ::-webkit-scrollbar{width:10px}
        ::-webkit-scrollbar-track{background:var(--bg-secondary)}
        ::-webkit-scrollbar-thumb{background:var(--border);border-radius:5px}
        ::-webkit-scrollbar-thumb:hover{background:var(--primary-light)}

        /* Visually hidden but accessible to screen readers */
        .visually-hidden{
            position:absolute;
            width:1px;
            height:1px;
            padding:0;
            margin:-1px;
            overflow:hidden;
            clip:rect(0,0,0,0);
            white-space:nowrap;
            border:0;
        }

        /* Photo attachment styles */
        .photo-upload-section{
            margin-top:20px;
            padding-top:20px;
            border-top:2px solid var(--border-light);
        }
        .photo-upload-buttons{
            display:flex;
            gap:10px;
            margin-top:16px;
            flex-wrap:wrap;
        }
        .photo-upload-buttons .btn{
            flex:1;
            min-width:0;
            font-size:14px;
            padding:10px 16px;
        }
        @media(max-width:700px){
            .photo-upload-buttons{
                flex-direction:column;
            }
            .photo-upload-buttons .btn{
                width:100%;
            }
        }
        .photo-preview-grid{
            display:grid;
            grid-template-columns:repeat(auto-fill, minmax(120px, 1fr));
            gap:12px;
        }
        .photo-preview-item{
            position:relative;
            aspect-ratio:1;
            border-radius:12px;
            overflow:hidden;
            border:2px solid var(--border);
            box-shadow:var(--shadow);
        }
        .photo-preview-item img{
            width:100%;
            height:100%;
            object-fit:cover;
        }
        .photo-preview-item .remove-photo{
            position:absolute;
            top:4px;
            right:4px;
            background:rgba(239, 68, 68, 0.95);
            color:#ffffff;
            border:none;
            border-radius:50%;
            width:28px;
            height:28px;
            font-size:18px;
            cursor:pointer;
            display:flex;
            align-items:center;
            justify-content:center;
            transition:all 0.2s ease;
            font-weight:300;
        }
        .photo-preview-item .remove-photo:hover{
            background:#dc2626;
            transform:scale(1.1);
        }
        .photo-gallery{
            display:grid;
            grid-template-columns:repeat(auto-fill, minmax(100px, 1fr));
            gap:8px;
            margin-top:12px;
        }
        .photo-gallery img{
            width:100%;
            aspect-ratio:1;
            object-fit:cover;
            border-radius:10px;
            border:2px solid var(--border);
            cursor:pointer;
            transition:all 0.2s ease;
        }
        .photo-gallery img:hover{
            transform:scale(1.05);
            box-shadow:var(--shadow-md);
        }
        /* Photo modal */
        .photo-modal{
            position:fixed;
            top:0;
            left:0;
            right:0;
            bottom:0;
            background:rgba(0, 0, 0, 0.9);
            z-index:4000;
            display:none;
            align-items:center;
            justify-content:center;
            padding:20px;
        }
        .photo-modal.active{display:flex}
        .photo-modal img{
            max-width:100%;
            max-height:90vh;
            border-radius:12px;
            box-shadow:var(--shadow-xl);
        }
        .photo-modal .close-btn{
            position:absolute;
            top:20px;
            right:20px;
        }

        /* Pairings section */
        .pairings-section{
            margin-top:20px;
            padding-top:20px;
            border-top:2px solid var(--border-light);
        }
        .pairing-category{
            margin-bottom:24px;
        }
        .pairing-category h3{
            font-size:16px;
            font-weight:700;
            color:var(--text-secondary);
            margin:0 0 12px 0;
            display:flex;
            align-items:center;
            gap:8px;
        }
        .pairing-list{
            display:flex;
            flex-direction:column;
            gap:8px;
            margin-bottom:12px;
        }
        .pairing-item{
            display:flex;
            justify-content:space-between;
            align-items:center;
            padding:10px 12px;
            background:var(--bg-secondary);
            border:1px solid var(--border);
            border-radius:10px;
            font-size:14px;
        }
        .pairing-item.good{
            background:#d1fae5;
            border-color:var(--accent);
        }
        .pairing-item.bad{
            background:#fee2e2;
            border-color:#ef4444;
        }
        .pairing-item-name{
            font-weight:600;
            display:flex;
            align-items:center;
            gap:6px;
        }
        .pairing-item-remove{
            background:transparent;
            border:none;
            color:var(--muted);
            cursor:pointer;
            font-size:18px;
            padding:4px 8px;
            border-radius:6px;
            transition:all 0.2s ease;
        }
        .pairing-item-remove:hover{
            background:rgba(239, 68, 68, 0.2);
            color:#ef4444;
        }
        .add-pairing-btn{
            display:inline-flex;
            align-items:center;
            gap:6px;
            padding:8px 14px;
            font-size:13px;
            background:var(--card);
            border:2px dashed var(--border);
            border-radius:10px;
            cursor:pointer;
            transition:all 0.2s ease;
            color:var(--text-secondary);
            font-weight:600;
        }
        .add-pairing-btn:hover{
            border-color:var(--primary);
            color:var(--primary);
            background:var(--bg-secondary);
        }
        .empty-pairings{
            color:var(--muted);
            font-size:13px;
            font-style:italic;
            padding:8px 0;
        }
    </style>
</head>
<body>
<header>
    <div class="search-wrapper">
        <label for="searchInput" class="visually-hidden">Search items</label>
        <input id="searchInput" type="text" placeholder="Search by name, notes, or barcode…"/>
        <button class="barcode-btn" id="barcodeScanBtn" title="Scan barcode">
            <img src="icons/barcode.png" alt="Scan barcode" />
        </button>
    </div>
</header>

<main>
    <!-- Scanner section (shown in modal) -->
    <div id="scannerModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Scan Barcode</h2>
                <button class="close-btn" id="closeScannerBtn">×</button>
            </div>
            <div style="position:relative">
                <video id="preview" playsinline></video>
            </div>
            <div class="muted" style="margin-top:8px;text-align:center" id="scanHint"></div>
        </div>
    </div>

    <!-- Item details modal -->
    <div id="detailsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Item Details</h2>
                <button class="close-btn" id="closeDetailsBtn">×</button>
            </div>
            <div class="modal-body">
                <div id="detailsContent"></div>
            </div>
            <div class="modal-footer">
                <div class="row" style="margin:0" id="detailsButtons">
                    <!-- Buttons will be dynamically inserted here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Editor modal -->
    <div id="editorModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="editorTitle">Add Item</h2>
                <button class="close-btn" id="closeEditorBtn">×</button>
            </div>
            <div class="modal-body">
                <div id="editorFields">
                    <!-- Dynamic fields will be generated here -->
                </div>
            </div>
            <div class="modal-footer">
                <div class="row" style="margin:0">
                    <button class="btn primary" id="saveBtn">Save</button>
                    <button class="btn" id="cancelEditorBtn">Cancel</button>
                </div>
                <div class="muted" style="margin-top:8px" id="status"></div>
            </div>
        </div>
    </div>

    <!-- Items list -->
    <div id="results" class="list"></div>
</main>

<!-- Floating add button -->
<button class="fab" id="fabBtn" title="Add new item">+</button>

<!-- Photo viewer modal -->
<div id="photoModal" class="photo-modal">
    <button class="close-btn" id="closePhotoBtn">×</button>
    <img id="photoModalImg" src="" alt="Full size photo" />
</div>

<!-- Pairing selector modal -->
<div id="pairingSelectorModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 id="pairingSelectorTitle">Select Item to Pair</h2>
            <button class="close-btn" id="closePairingSelectorBtn">×</button>
        </div>
        <div style="margin-bottom:16px">
            <div class="search-wrapper">
                <label for="pairingSearchInput" class="visually-hidden">Search items to pair</label>
                <input id="pairingSearchInput" type="text" placeholder="Search items to pair..."/>
                <button class="barcode-btn" id="pairingBarcodeScanBtn" title="Scan barcode">
                    <img src="icons/barcode.png" alt="Scan barcode" />
                </button>
            </div>
        </div>
        <div id="pairingItemsList" class="list" style="max-height:400px;overflow-y:auto"></div>
        <div class="muted" style="margin-top:8px;text-align:center" id="pairingStatus"></div>
    </div>
</div>

<!-- ZXing barcode scanner via ESM build -->
<script type="module">
    // ====== Load item types configuration ======
    let ITEM_TYPES_CONFIG = {};

    // iOS Safari select double-tap mitigation: ensure programmatic focus on first touch
    function enhanceSelectInteractivity(root=document){
      // Only run on iOS devices (simple heuristic)
      const ua = navigator.userAgent || '';
      const isiOS = /iPad|iPhone|iPod/.test(ua) && !window.MSStream;
      if(!isiOS) return; // Avoid altering behavior on non-iOS
      root.querySelectorAll('select').forEach(sel => {
        if(sel.__enhanced) return; sel.__enhanced = true;
        const focusIfNeeded = () => {
          if(document.activeElement !== sel){ sel.focus(); }
        };
        sel.addEventListener('touchstart', focusIfNeeded, { passive:true });
        sel.addEventListener('pointerdown', focusIfNeeded, { passive:true });
        sel.addEventListener('touchend', () => {
          // Sometimes first tap focuses but doesn't open; a quick second programmatic focus helps.
          setTimeout(focusIfNeeded, 30);
        }, { passive:true });
      });
    }

    // ====== Simple IndexedDB wrapper (no external deps) ======
    const DB_NAME = 'gourmetapp-db';
    const STORE = 'items';
    const dbp = new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, 1);
      req.onupgradeneeded = () => {
        const db = req.result;
        const store = db.createObjectStore(STORE, { keyPath: 'id', autoIncrement: true });
        store.createIndex('by_barcode', 'barcode', { unique: false });
        store.createIndex('by_name', 'name', { unique: false });
        store.createIndex('by_type', 'type', { unique: false });
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });

    async function tx(mode = 'readonly') {
      const db = await dbp; return db.transaction(STORE, mode).objectStore(STORE);
    }
    async function addItem(item){ const store = await tx('readwrite'); return new Promise((res,rej)=>{ const r=store.add({...item, createdAt: Date.now(), updatedAt: Date.now()}); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
    async function updateItem(id, patch){ const store = await tx('readwrite'); const get=store.get(id); return new Promise((res,rej)=>{ get.onsuccess=()=>{ const cur=get.result; if(!cur) return rej(new Error('Not found')); const put=store.put({...cur, ...patch, updatedAt: Date.now()}); put.onsuccess=()=>res(put.result); put.onerror=()=>rej(put.error); }; get.onerror=()=>rej(get.error); }); }
    async function deleteItem(id){
      // First, get the item to check for pairings
      const item = await getItem(id);

      // Clean up all pairing references in other items
      if (item && item.pairings) {
        const allPairedIds = [...(item.pairings.good || []), ...(item.pairings.bad || [])];

        for (const pairedId of allPairedIds) {
          const pairedItem = await getItem(pairedId);
          if (pairedItem && pairedItem.pairings) {
            // Remove this item's ID from both good and bad pairings
            if (pairedItem.pairings.good) {
              pairedItem.pairings.good = pairedItem.pairings.good.filter(pid => pid !== id);
            }
            if (pairedItem.pairings.bad) {
              pairedItem.pairings.bad = pairedItem.pairings.bad.filter(pid => pid !== id);
            }
            await updateItem(pairedId, { pairings: pairedItem.pairings });
          }
        }
      }

      // Now delete the item itself
      const store = await tx('readwrite');
      return new Promise((res,rej)=>{
        const r=store.delete(id);
        r.onsuccess=()=>res();
        r.onerror=()=>rej(r.error);
      });
    }
    async function getItem(id){
      const store = await tx('readonly');
      return new Promise((res,rej)=>{ const r=store.get(id); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); });
    }
    async function listAll(){
      const store = await tx('readonly');
      return new Promise((res)=>{ const out=[]; const c=store.openCursor(); c.onsuccess=()=>{ const cur=c.result; if(cur){ out.push(cur.value); cur.continue(); } else res(out); }; });
    }
    async function findByBarcode(code){
      const store = await tx('readonly');
      return new Promise((res)=>{ const idx=store.index('by_barcode'); const r=idx.getAll(code); r.onsuccess=()=>res(r.result||[]); });
    }
    async function searchByText(q){
      q=(q||'').toLowerCase();
      const all = await listAll();
      if(!q) return all;
      return all.filter(it => (it.name||'').toLowerCase().includes(q) || (it.notes||'').toLowerCase().includes(q) || (it.barcode||'').includes(q));
    }

    // ====== Star Rating Helper ======
    function renderStars(rating, interactive = false) {
      const stars = [];
      const fullStars = Math.floor(rating);
      const hasHalf = rating % 1 >= 0.5;

      for (let i = 1; i <= 5; i++) {
        if (i <= fullStars) {
          stars.push(`<span class="star filled" data-value="${i}">★</span>`);
        } else if (i === fullStars + 1 && hasHalf) {
          stars.push(`<span class="star half" data-value="${i - 0.5}">★</span>`);
        } else {
          stars.push(`<span class="star" data-value="${i}">★</span>`);
        }
      }

      const className = interactive ? 'star-rating' : 'star-rating-display';
      return `<div class="${className}">${stars.join('')}</div>`;
    }

    function setupStarRating(container, initialValue = 0) {
      let currentRating = initialValue;
      const stars = container.querySelectorAll('.star');

      stars.forEach((star, index) => {
        // Click on left half = half star, click on right half = full star
        star.addEventListener('click', (e) => {
          const rect = star.getBoundingClientRect();
          const clickX = e.clientX - rect.left;
          const starWidth = rect.width;
          const isLeftHalf = clickX < starWidth / 2;

          let value;
          if (isLeftHalf) {
            value = index + 0.5;
          } else {
            value = index + 1;
          }

          currentRating = value;
          updateStars(value);
        });

        star.addEventListener('mousemove', (e) => {
          const rect = star.getBoundingClientRect();
          const clickX = e.clientX - rect.left;
          const starWidth = rect.width;
          const isLeftHalf = clickX < starWidth / 2;

          let value;
          if (isLeftHalf) {
            value = index + 0.5;
          } else {
            value = index + 1;
          }
          updateStars(value);
        });
      });

      container.addEventListener('mouseleave', () => {
        updateStars(currentRating);
      });

      function updateStars(rating) {
        const fullStars = Math.floor(rating);
        const hasHalf = rating % 1 >= 0.5;

        stars.forEach((star, idx) => {
          star.classList.remove('filled', 'half');
          if (idx < fullStars) {
            star.classList.add('filled');
          } else if (idx === fullStars && hasHalf) {
            star.classList.add('half');
          }
        });
      }

      updateStars(currentRating);

      return {
        getValue: () => currentRating,
        setValue: (value) => {
          currentRating = value;
          updateStars(value);
        }
      };
    }

    // ====== UI helpers ======
    const el = id => document.getElementById(id);
    const resultsEl = el('results');
    let currentEditingId = null;
    let starRatingController = null;
    let currentPhotos = []; // Store photos for current item being edited
    let currentPairings = { good: [], bad: [] }; // Store pairings for current item being edited

    // Helper function to open modal and reset scroll position
    function openModal(modalId) {
      const modal = el(modalId);
      modal.classList.add('active');

      // Reset scroll position for modal body
      const modalBody = modal.querySelector('.modal-body');
      if (modalBody) {
        modalBody.scrollTop = 0;
      }

      // Also reset the modal content scroll if it exists
      const modalContent = modal.querySelector('.modal-content');
      if (modalContent) {
        modalContent.scrollTop = 0;
      }
    }

    // ====== Pairing Management with Bidirectional Linking ======
    let pairingMode = null; // 'good' or 'bad'
    let pairingSourceId = null; // ID of the item being edited

    // Add pairing bidirectionally
    async function addPairing(sourceId, targetId, type) {
      const sourceItem = await getItem(sourceId);
      const targetItem = await getItem(targetId);

      if (!sourceItem || !targetItem) return;

      // Initialize pairings if not exist
      if (!sourceItem.pairings) sourceItem.pairings = { good: [], bad: [] };
      if (!targetItem.pairings) targetItem.pairings = { good: [], bad: [] };

      // Add to source item
      if (!sourceItem.pairings[type].includes(targetId)) {
        sourceItem.pairings[type].push(targetId);
      }

      // Add reverse pairing to target item
      if (!targetItem.pairings[type].includes(sourceId)) {
        targetItem.pairings[type].push(sourceId);
      }

      // Save both items
      await updateItem(sourceId, { pairings: sourceItem.pairings });
      await updateItem(targetId, { pairings: targetItem.pairings });
    }

    // Remove pairing bidirectionally
    async function removePairing(sourceId, targetId, type) {
      const sourceItem = await getItem(sourceId);
      const targetItem = await getItem(targetId);

      if (!sourceItem || !targetItem) return;

      // Remove from source item
      if (sourceItem.pairings && sourceItem.pairings[type]) {
        sourceItem.pairings[type] = sourceItem.pairings[type].filter(id => id !== targetId);
        await updateItem(sourceId, { pairings: sourceItem.pairings });
      }

      // Remove from target item
      if (targetItem.pairings && targetItem.pairings[type]) {
        targetItem.pairings[type] = targetItem.pairings[type].filter(id => id !== sourceId);
        await updateItem(targetId, { pairings: targetItem.pairings });
      }
    }

    // Open pairing selector modal
    async function openPairingSelector(type) {
      pairingMode = type;
      pairingSourceId = currentEditingId;

      const title = type === 'good' ? 'Select Good Pairing' : 'Select Bad Pairing';
      el('pairingSelectorTitle').textContent = title;
      el('pairingSearchInput').value = '';
      openModal('pairingSelectorModal');

      await refreshPairingList();
    }

    function closePairingSelector() {
      el('pairingSelectorModal').classList.remove('active');
      pairingMode = null;
      pairingSourceId = null;
    }

    // Render available items for pairing
    async function refreshPairingList() {
      const query = el('pairingSearchInput').value.trim();
      const allItems = await searchByText(query);

      // Exclude current item being edited
      const availableItems = allItems.filter(item => item.id !== currentEditingId);

      const pairingItemsList = el('pairingItemsList');

      if (availableItems.length === 0) {
        pairingItemsList.innerHTML = '<div class="empty-state" style="padding:40px 20px">No items available to pair</div>';
        return;
      }

      pairingItemsList.innerHTML = availableItems.map(item => {
        const typeInfo = getTypeInfo(item.type);
        const isAlreadyPaired = currentPairings.good.includes(item.id) || currentPairings.bad.includes(item.id);

        return `
          <div class="item ${isAlreadyPaired ? 'selected' : ''}" data-pairing-item-id="${item.id}">
            <div style="display:flex;justify-content:space-between;align-items:center">
              <div style="flex:1">
                <div style="font-weight:700;font-size:16px">${typeInfo.icon} ${escapeHtml(item.name||'Unnamed')}</div>
                <div class="muted" style="font-size:12px;margin-top:4px">${typeInfo.label}</div>
              </div>
              ${isAlreadyPaired ? '<div class="badge">Already paired</div>' : ''}
            </div>
          </div>
        `;
      }).join('');

      // Bind click events
      pairingItemsList.querySelectorAll('.item').forEach(itemEl => {
        itemEl.onclick = async () => {
          const targetId = Number(itemEl.getAttribute('data-pairing-item-id'));

          // Check if already paired
          if (currentPairings.good.includes(targetId) || currentPairings.bad.includes(targetId)) {
            el('pairingStatus').textContent = 'This item is already paired';
            return;
          }

          // Add to current pairings
          currentPairings[pairingMode].push(targetId);

          // If editing existing item, save immediately with bidirectional link
          if (currentEditingId) {
            await addPairing(currentEditingId, targetId, pairingMode);
            el('pairingStatus').textContent = `${pairingMode === 'good' ? 'Good' : 'Bad'} pairing added!`;
            setTimeout(() => {
              closePairingSelector();
              // Re-render pairings section in editor
              renderPairingsInEditor();
            }, 500);
          } else {
            // For new items, just add to current pairings
            el('pairingStatus').textContent = 'Pairing added! Save the item to finalize.';
            setTimeout(() => {
              closePairingSelector();
              renderPairingsInEditor();
            }, 500);
          }
        };
      });
    }

    // Render pairings section in editor
    async function renderPairingsInEditor() {
      const container = document.getElementById('pairingsEditorContainer');
      if (!container) return;

      const allItems = await listAll();

      let html = '<div class="pairings-section">';

      // Good pairings
      html += '<div class="pairing-category">';
      html += '<h3>✅ Pairs well with...</h3>';

      if (currentPairings.good.length === 0) {
        html += '<div class="empty-pairings">No pairings yet</div>';
      } else {
        html += '<div class="pairing-list">';
        for (const pairedId of currentPairings.good) {
          const pairedItem = allItems.find(it => it.id === pairedId);
          if (pairedItem) {
            const typeInfo = getTypeInfo(pairedItem.type);
            html += `
              <div class="pairing-item good">
                <div class="pairing-item-name">
                  <span>${typeInfo.icon}</span>
                  <span>${escapeHtml(pairedItem.name)}</span>
                </div>
                <button class="pairing-item-remove" data-pairing-id="${pairedId}" data-pairing-type="good" type="button">×</button>
              </div>
            `;
          }
        }
        html += '</div>';
      }
      html += '<button class="add-pairing-btn" id="addGoodPairingBtn" type="button">+ Add Pairing</button>';
      html += '</div>';

      // Bad pairings
      html += '<div class="pairing-category">';
      html += '<h3>❌ Not a good match for...</h3>';

      if (currentPairings.bad.length === 0) {
        html += '<div class="empty-pairings">No pairings yet</div>';
      } else {
        html += '<div class="pairing-list">';
        for (const pairedId of currentPairings.bad) {
          const pairedItem = allItems.find(it => it.id === pairedId);
          if (pairedItem) {
            const typeInfo = getTypeInfo(pairedItem.type);
            html += `
              <div class="pairing-item bad">
                <div class="pairing-item-name">
                  <span>${typeInfo.icon}</span>
                  <span>${escapeHtml(pairedItem.name)}</span>
                </div>
                <button class="pairing-item-remove" data-pairing-id="${pairedId}" data-pairing-type="bad" type="button">×</button>
              </div>
            `;
          }
        }
        html += '</div>';
      }
      html += '<button class="add-pairing-btn" id="addBadPairingBtn" type="button">+ Add Pairing</button>';
      html += '</div>';

      html += '</div>';

      container.innerHTML = html;

      // Bind add buttons
      const addGoodBtn = document.getElementById('addGoodPairingBtn');
      if (addGoodBtn) {
        addGoodBtn.onclick = () => openPairingSelector('good');
      }

      const addBadBtn = document.getElementById('addBadPairingBtn');
      if (addBadBtn) {
        addBadBtn.onclick = () => openPairingSelector('bad');
      }

      // Bind remove buttons
      container.querySelectorAll('.pairing-item-remove').forEach(btn => {
        btn.onclick = async () => {
          const pairedId = Number(btn.getAttribute('data-pairing-id'));
          const type = btn.getAttribute('data-pairing-type');

          currentPairings[type] = currentPairings[type].filter(id => id !== pairedId);

          // If editing existing item, remove bidirectionally
          if (currentEditingId) {
            await removePairing(currentEditingId, pairedId, type);
          }

          await renderPairingsInEditor();
        };
      });
    }

    // Render pairings in details view
    async function renderPairingsHTML(item) {
      if (!item.pairings || (item.pairings.good.length === 0 && item.pairings.bad.length === 0)) {
        return '';
      }

      const allItems = await listAll();
      let html = '<div class="pairings-section">';

      // Good pairings
      if (item.pairings.good.length > 0) {
        html += '<div class="pairing-category">';
        html += '<h3>✅ Pairs well with...</h3>';
        html += '<div class="pairing-list">';

        for (const pairedId of item.pairings.good) {
          const pairedItem = allItems.find(it => it.id === pairedId);
          if (pairedItem) {
            const typeInfo = getTypeInfo(pairedItem.type);
            html += `
              <div class="pairing-item good" style="cursor:pointer" data-view-item-id="${pairedId}">
                <div class="pairing-item-name">
                  <span>${typeInfo.icon}</span>
                  <span>${escapeHtml(pairedItem.name)}</span>
                </div>
              </div>
            `;
          }
        }
        html += '</div></div>';
      }

      // Bad pairings
      if (item.pairings.bad.length > 0) {
        html += '<div class="pairing-category">';
        html += '<h3>❌ Not a good match for...</h3>';
        html += '<div class="pairing-list">';

        for (const pairedId of item.pairings.bad) {
          const pairedItem = allItems.find(it => it.id === pairedId);
          if (pairedItem) {
            const typeInfo = getTypeInfo(pairedItem.type);
            html += `
              <div class="pairing-item bad" style="cursor:pointer" data-view-item-id="${pairedId}">
                <div class="pairing-item-name">
                  <span>${typeInfo.icon}</span>
                  <span>${escapeHtml(pairedItem.name)}</span>
                </div>
              </div>
            `;
          }
        }
        html += '</div></div>';
      }

      html += '</div>';
      return html;
    }

    // ====== Photo Management ======
    // Convert file to base64 data URL
    async function fileToDataURL(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    // Capture photo using camera
    async function capturePhoto() {
      return new Promise((resolve, reject) => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        input.capture = 'environment'; // Use back camera on mobile

        input.onchange = async (e) => {
          const file = e.target.files[0];
          if (file) {
            try {
              const dataURL = await fileToDataURL(file);
              resolve(dataURL);
            } catch (err) {
              reject(err);
            }
          }
        };

        input.click();
      });
    }

    // Select photo from device
    async function selectPhoto() {
      return new Promise((resolve, reject) => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        input.multiple = false;

        input.onchange = async (e) => {
          const file = e.target.files[0];
          if (file) {
            try {
              const dataURL = await fileToDataURL(file);
              resolve(dataURL);
            } catch (err) {
              reject(err);
            }
          }
        };

        input.click();
      });
    }

    // Render photo preview grid in editor
    function renderPhotoPreview() {
      const container = document.getElementById('photoPreviewContainer');
      if (!container) return;

      if (currentPhotos.length === 0) {
        container.innerHTML = '<div class="muted" style="text-align:center;padding:20px">No photos attached</div>';
        return;
      }

      container.innerHTML = currentPhotos.map((photo, index) => `
        <div class="photo-preview-item">
          <img src="${photo}" alt="Photo ${index + 1}" />
          <button class="remove-photo" data-index="${index}" type="button">×</button>
        </div>
      `).join('');

      // Bind remove buttons
      container.querySelectorAll('.remove-photo').forEach(btn => {
        btn.onclick = () => {
          const index = parseInt(btn.getAttribute('data-index'));
          currentPhotos.splice(index, 1);
          renderPhotoPreview();
        };
      });
    }

    // Show photo in full screen modal
    function showPhotoModal(photoDataURL) {
      const modal = el('photoModal');
      const img = el('photoModalImg');
      img.src = photoDataURL;
      modal.classList.add('active');
    }

    function closePhotoModal() {
      el('photoModal').classList.remove('active');
    }

    function sortByRating(items){
      return items.sort((a, b) => (Number(b.rating)||0) - (Number(a.rating)||0));
    }

    function getTypeInfo(typeKey) {
      return ITEM_TYPES_CONFIG[typeKey] || { label: typeKey, icon: '📦', fields: [] };
    }

    function renderList(items){
      const sorted = sortByRating([...items]);
      if(sorted.length === 0){
        resultsEl.innerHTML = '<div class="empty-state">No items found. Tap the + button to add your first item!</div>';
        return;
      }
      resultsEl.innerHTML = sorted.map(it => {
        const typeInfo = getTypeInfo(it.type);
        return `
        <div class="item" data-id="${it.id}">
          <div class="row" style="justify-content:space-between;align-items:center">
            <div style="flex:1">
              <div style="font-weight:700;font-size:16px">${typeInfo.icon} ${escapeHtml(it.name||'Unnamed')}</div>
              <div class="muted" style="font-size:12px;margin-top:4px">${typeInfo.label}</div>
            </div>
            <div>${renderStars(Number(it.rating)||0, false)}</div>
          </div>
        </div>`;
      }).join('');

      // Bind click events to show details
      resultsEl.querySelectorAll('.item').forEach(itemEl => {
        itemEl.onclick = () => {
          const id = Number(itemEl.getAttribute('data-id'));
          showItemDetails(id);
        };
      });
    }

    async function showItemDetails(id){
      const item = await getItem(id);
      if(!item) return;

      const typeInfo = getTypeInfo(item.type);
      const detailsContent = el('detailsContent');
      const detailsButtons = el('detailsButtons');

      let fieldsHTML = `
        <div class="detail-row">
          <div class="detail-label">Name</div>
          <div class="detail-value">${escapeHtml(item.name||'Unnamed')}</div>
        </div>
        <div class="detail-row">
          <div class="detail-label">Type</div>
          <div class="detail-value">${typeInfo.icon} ${escapeHtml(typeInfo.label)}</div>
        </div>
        <div class="detail-row">
          <div class="detail-label">Rating</div>
          <div class="detail-value">${renderStars(Number(item.rating)||0, false)}</div>
        </div>
        ${item.barcode ? `<div class="detail-row">
          <div class="detail-label">Barcode</div>
          <div class="detail-value">${escapeHtml(item.barcode)}</div>
        </div>` : ''}
      `;

      // Add dynamic fields
      typeInfo.fields.forEach(field => {
        if (item[field.name]) {
          fieldsHTML += `
            <div class="detail-row">
              <div class="detail-label">${escapeHtml(field.label)}</div>
              <div class="detail-value">${escapeHtml(String(item[field.name]))}</div>
            </div>
          `;
        }
      });

      fieldsHTML += `
        ${item.notes ? `<div class="detail-row">
          <div class="detail-label">Notes</div>
          <div class="detail-value">${escapeHtml(item.notes)}</div>
        </div>` : ''}
        <div class="detail-row">
          <div class="detail-label">Last Updated</div>
          <div class="detail-value">${new Date(item.updatedAt||Date.now()).toLocaleString()}</div>
        </div>
      `;

      // Add photos if available
      let photosHTML = '';
      if (item.photos && Array.isArray(item.photos) && item.photos.length > 0) {
        photosHTML = `
          <div style="margin-top:20px;padding-top:20px;border-top:2px solid var(--border-light)">
            <label>Photos</label>
            <div class="photo-gallery">
              ${item.photos.map((photo, index) => `
                <img src="${photo}" alt="Photo ${index + 1}" data-photo-url="${photo}" class="photo-thumbnail" />
              `).join('')}
            </div>
          </div>
        `;
      }

      // Render pairings
      const pairingsHTML = await renderPairingsHTML(item);

      detailsContent.innerHTML = `
        <div class="detail-section">${fieldsHTML}</div>
        ${photosHTML}
        ${pairingsHTML}
      `;

      // Set buttons in footer
      detailsButtons.innerHTML = `
        <button class="btn primary" id="editDetailsBtn">Edit</button>
        <button class="btn" id="deleteDetailsBtn">Delete</button>
      `;

      openModal('detailsModal');

      // Bind photo thumbnails to show full screen
      detailsContent.querySelectorAll('.photo-thumbnail').forEach(img => {
        img.onclick = () => {
          const photoUrl = img.getAttribute('data-photo-url');
          showPhotoModal(photoUrl);
        };
      });

      // Bind pairing items to show their details
      detailsContent.querySelectorAll('[data-view-item-id]').forEach(pairingEl => {
        pairingEl.onclick = () => {
          const pairedItemId = Number(pairingEl.getAttribute('data-view-item-id'));
          showItemDetails(pairedItemId);
        };
      });

      // Bind edit button
      el('editDetailsBtn').onclick = () => {
        el('detailsModal').classList.remove('active');
        openEditor(item);
      };

      // Bind delete button
      el('deleteDetailsBtn').onclick = async () => {
        if(confirm(`Delete "${item.name}"?`)){
          await deleteItem(id);
          el('detailsModal').classList.remove('active');
          await refreshList();
          setStatus('Item deleted.');
        }
      };
    }

    function renderEditorFields(selectedType, itemData = {}) {
      const typeInfo = getTypeInfo(selectedType);
      const editorFields = el('editorFields');

      console.log('Rendering editor for type:', selectedType);
      console.log('Type info:', typeInfo);
      console.log('Fields count:', typeInfo.fields.length);

      let html = '<div class="grid">';

      // Type selector
      html += '<div class="field-group"><label>Type *</label><select id="typeSelect">';
      Object.keys(ITEM_TYPES_CONFIG).forEach(key => {
        const cfg = ITEM_TYPES_CONFIG[key];
        html += `<option value="${key}" ${key === selectedType ? 'selected' : ''}>${cfg.icon} ${cfg.label}</option>`;
      });
      html += '</select></div>';

      // Name (always)
      html += `<div class="field-group"><label>Name *</label><input id="nameInput" placeholder="e.g., Cabernet Sauvignon" value="${escapeHtml(itemData.name||'')}"/></div>`;

      // Barcode (always) with scan button
      html += `<div class="field-group"><label>Barcode (optional)</label>
        <div class="input-with-barcode">
          <input id="barcodeInput" placeholder="e.g., 5991234567890" value="${escapeHtml(itemData.barcode||'')}"/>
          <button class="barcode-btn" id="barcodeInputScanBtn" type="button" title="Scan barcode">
            <img src="icons/barcode.png" alt="Scan barcode" />
          </button>
        </div>
      </div>`;

      // Rating (always) - full width
      html += `<div class="field-group" style="grid-column:1/-1"><label>Rating *</label><div id="ratingContainer">${renderStars(Number(itemData.rating)||0, true)}</div></div>`;

      // Dynamic fields container (will be populated separately)
      html += `<div id="dynamicFieldsContainer" style="grid-column:1/-1"></div>`;

      // Notes (always) - full width
      html += `<div class="field-group" style="grid-column:1/-1"><label>Notes</label><textarea id="notesInput" rows="4" placeholder="Tasting notes, where you had it, etc.">${escapeHtml(itemData.notes||'')}</textarea></div>`;

      // Photos (optional) - full width
      html += `<div class="field-group" style="grid-column:1/-1">
        <label>Photos (optional)</label>
        <div id="photoPreviewContainer" class="photo-preview-grid"></div>
        <div class="photo-upload-buttons">
          <button class="btn primary" id="capturePhotoBtn" type="button">📷 Take Photo</button>
          <button class="btn" id="selectPhotoBtn" type="button">🖼️ Choose Photo</button>
        </div>
      </div>`;

      // Pairings section - full width
      html += `<div id="pairingsEditorContainer" style="grid-column:1/-1"></div>`;

      html += '</div>';

      console.log('Generated HTML length:', html.length);
      editorFields.innerHTML = html;

      // Populate dynamic fields
      updateDynamicFields(selectedType, itemData);

      // Apply iOS select interaction enhancement after DOM insertion
      enhanceSelectInteractivity(editorFields);

      // Setup star rating
      const ratingContainer = el('ratingContainer');
      starRatingController = setupStarRating(ratingContainer, Number(itemData.rating)||0);

      // Setup barcode input scan button
      const barcodeInputScanBtn = el('barcodeInputScanBtn');
      if (barcodeInputScanBtn) {
        barcodeInputScanBtn.onclick = () => startScanForInput();
      }

      // Handle type change - update only dynamic fields instead of full re-render
      const typeSelect = el('typeSelect');
      typeSelect.onchange = (e) => {
        const newType = e.target.value;
        setTimeout(() => {
          const baseData = collectFormData();
          updateDynamicFields(newType, baseData);
        }, 120); // Slightly longer delay to let iOS close picker cleanly
      };

      // Setup photo capture and selection
      el('capturePhotoBtn').onclick = async () => {
        const dataURL = await capturePhoto();
        if (dataURL) {
          currentPhotos.push(dataURL);
          renderPhotoPreview();
        }
      };

      el('selectPhotoBtn').onclick = async () => {
        const dataURL = await selectPhoto();
        if (dataURL) {
          currentPhotos.push(dataURL);
          renderPhotoPreview();
        }
      };

      // Initial render of photos
      if (itemData.photos && Array.isArray(itemData.photos)) {
        currentPhotos = itemData.photos;
        renderPhotoPreview();
      }
    }

    // Update only dynamic fields section to avoid full form rebuild (improves iOS picker reliability)
    function updateDynamicFields(selectedType, itemData={}) {
      const container = document.getElementById('dynamicFieldsContainer');
      if(!container) return;
      const typeInfo = getTypeInfo(selectedType);
      let html = '<div class="grid" style="grid-template-columns:1fr 1fr;gap:16px">';
      typeInfo.fields.forEach(field => {
        html += '<div class="field-group">';
        html += `<label>${escapeHtml(field.label)}</label>`;
        if (field.type === 'enum') {
          html += `<select id="field_${field.name}">`;
          html += '<option value="">-- Select --</option>';
          field.options.forEach(opt => {
            const selected = itemData[field.name] === opt ? 'selected' : '';
            html += `<option value="${escapeHtml(opt)}" ${selected}>${escapeHtml(opt)}</option>`;
          });
          html += '</select>';
        } else if (field.type === 'number') {
          html += `<input type="number" id="field_${field.name}" value="${itemData[field.name]||''}" placeholder="e.g., 2015"/>`;
        } else {
          html += `<input type="text" id="field_${field.name}" value="${escapeHtml(itemData[field.name]||'')}" placeholder="Enter ${field.label.toLowerCase()}"/>`;
        }
        html += '</div>';
      });
      html += '</div>';
      container.innerHTML = html;
      enhanceSelectInteractivity(container);
    }

    // ====== Collect form data (formerly present, restored) ======
    function collectFormData() {
      const selectedType = el('typeSelect')?.value || Object.keys(ITEM_TYPES_CONFIG)[0];
      const typeInfo = getTypeInfo(selectedType);
      const data = {
        type: selectedType,
        name: el('nameInput')?.value?.trim() || '',
        barcode: el('barcodeInput')?.value?.trim() || '',
        rating: starRatingController?.getValue() || 0,
        notes: el('notesInput')?.value?.trim() || ''
      };
      typeInfo.fields.forEach(field => {
        const fieldEl = el(`field_${field.name}`);
        if (fieldEl && fieldEl.value) {
          data[field.name] = field.type === 'number' ? Number(fieldEl.value) : fieldEl.value;
        }
      });
      data.photos = currentPhotos;
      data.pairings = currentPairings;
      return data;
    }

    // ====== Open / Close editor (restored) ======
    function openEditor(item = null){
      if(item){
        el('editorTitle').textContent = 'Edit Item';
        currentEditingId = item.id;
        currentPairings = item.pairings ? { good: [...item.pairings.good], bad: [...item.pairings.bad] } : { good: [], bad: [] };
        renderEditorFields(item.type || Object.keys(ITEM_TYPES_CONFIG)[0], item);
      } else {
        el('editorTitle').textContent = 'Add Item';
        currentEditingId = null;
        currentPairings = { good: [], bad: [] };
        renderEditorFields(Object.keys(ITEM_TYPES_CONFIG)[0], {});
      }
      openModal('editorModal');
      enhanceSelectInteractivity(el('editorModal'));
      setStatus('');
      // Initialize pairings section after a brief delay
      setTimeout(() => renderPairingsInEditor(), 100);
    }
    function closeEditor(){
      el('editorModal').classList.remove('active');
      currentEditingId = null;
      starRatingController = null;
      currentPhotos = [];
      currentPairings = { good: [], bad: [] };
    }

    // ====== Refresh list & status helpers (restored) ======
    async function refreshList(){
      const query = el('searchInput').value.trim();
      const items = await searchByText(query);
      renderList(items);
    }
    function setStatus(msg){ el('status').textContent = msg; }
    function escapeHtml(s){
      return (s||'').replace(/[&<>"']/g, m => ({
        '&':'&amp;',
        '<':'&lt;',
        '>':'&gt;',
        '"':'&quot;',
        "'":'&#39;'
      }[m]));
    }

    // ====== External lookup (Open Food Facts) (restored) ======
    async function lookupByBarcodeOFF(code){
      try{
        const r = await fetch(`https://world.openfoodfacts.org/api/v0/product/${encodeURIComponent(code)}.json`);
        const j = await r.json();
        if(j && j.status === 1){
          const p = j.product||{};
            return {
              name: p.product_name || p.generic_name || 'Unknown product',
              type: Object.keys(ITEM_TYPES_CONFIG)[0] || 'wine',
              barcode: code,
              rating: 0,
              notes: p.brands ? `Brand: ${p.brands}` : ''
            };
        }
      }catch(e){/* ignore */}
      return null;
    }

    // ====== Barcode scanner logic (restored) ======
    import { BrowserMultiFormatReader } from 'https://cdn.jsdelivr.net/npm/@zxing/library@0.20.0/+esm';
    const codeReader = new BrowserMultiFormatReader();
    let currentStream = null;
    let availableCameras = [];
    let currentCameraIndex = 0;

    async function getAvailableCameras() {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const videoDevices = devices.filter(d => d.kind === 'videoinput');
      videoDevices.sort((a, b) => {
        const aBack = /back|rear|environment/i.test(a.label);
        const bBack = /back|rear|environment/i.test(b.label);
        if (aBack && !bBack) return -1;
        if (!aBack && bBack) return 1;
        return 0;
      });
      return videoDevices;
    }
    async function startCamera(onScanComplete){
      const vid = el('preview');
      try{
        availableCameras = await getAvailableCameras();
        const deviceId = availableCameras[currentCameraIndex]?.deviceId;
        if(currentStream){ currentStream.getTracks().forEach(t=>t.stop()); }
        currentStream = await navigator.mediaDevices.getUserMedia({
          video:{ deviceId: deviceId ? { exact: deviceId } : undefined, facingMode: deviceId ? undefined : { ideal:'environment' } }
        });
        vid.srcObject = currentStream; await vid.play();
        codeReader.decodeFromVideoDevice(deviceId || undefined, vid, async (res, err) => {
          if(res){
            const code = res.getText();
            el('scanHint').textContent = `Scanned: ${code}`;
            stopScan();
            if(onScanComplete) await onScanComplete(code);
          }
        });
      }catch(e){
        el('scanHint').textContent = 'Camera error: ' + e.message;
        setTimeout(stopScan, 3000);
      }
    }
    async function startScan(){
      el('scannerModal').classList.add('active');
      currentCameraIndex = 0;
      await startCamera(async (code) => {
        const items = await findByBarcode(code);
        if(items && items.length){
          el('searchInput').value = code; renderList(items);
        } else {
          el('searchInput').value = code; renderList([]);
          const fetched = await lookupByBarcodeOFF(code);
          if(fetched && confirm(`Barcode not found. Found "${fetched.name}" in Open Food Facts. Add it?`)){
            openEditor({...fetched, barcode: code});
          } else if(!fetched){
            if(confirm('Barcode not found. Add new item?')) openEditor({barcode: code});
          }
        }
      });
    }
    function stopScan(){
      try{ codeReader.reset(); }catch(_){ }
      if(currentStream){ currentStream.getTracks().forEach(t=>t.stop()); currentStream = null; }
      el('scannerModal').classList.remove('active');
      el('scanHint').textContent = '';
    }
    async function startScanForInput(){
      el('scannerModal').classList.add('active'); currentCameraIndex = 0;
      await startCamera(async (code) => { const barcodeInput = el('barcodeInput'); if(barcodeInput){ barcodeInput.value = code; } });
    }

    // ====== App Initialization (restored) ======
    async function initApp(){
      try{
        const response = await fetch('./item-types-config.json');
        ITEM_TYPES_CONFIG = await response.json();
        console.log('Loaded item types:', Object.keys(ITEM_TYPES_CONFIG));
      }catch(e){
        console.error('Could not load item types config:', e.message);
        ITEM_TYPES_CONFIG = { wine:{label:'Wine',icon:'🍷',fields:[]}, cheese:{label:'Cheese',icon:'🧀',fields:[]}, olives:{label:'Olives',icon:'🫒',fields:[]} };
      }
      el('searchInput').oninput = refreshList;
      el('barcodeScanBtn').onclick = startScan;
      el('closeScannerBtn')?.addEventListener('click', stopScan);
      el('closeDetailsBtn').onclick = () => el('detailsModal').classList.remove('active');
      el('fabBtn').onclick = () => openEditor();
      el('closeEditorBtn').onclick = closeEditor;
      el('cancelEditorBtn').onclick = closeEditor;

      // Pairing selector modal handlers
      el('closePairingSelectorBtn').onclick = closePairingSelector;
      el('pairingSearchInput').oninput = refreshPairingList;
      el('pairingBarcodeScanBtn').onclick = async () => {
        el('scannerModal').classList.add('active');
        currentCameraIndex = 0;
        await startCamera(async (code) => {
          const items = await findByBarcode(code);
          if (items && items.length > 0) {
            el('pairingSearchInput').value = code;
            await refreshPairingList();
          }
        });
      };
      el('pairingSelectorModal').onclick = (e) => {
        if (e.target === el('pairingSelectorModal')) {
          closePairingSelector();
        }
      };

      el('saveBtn').onclick = async () => {
        const payload = collectFormData();
        if(!payload.name){ setStatus('Please enter a name.'); return; }
        try{
          if(currentEditingId){
            await updateItem(currentEditingId, payload);
            setStatus('Item updated!');
          }
          else {
            // For new items, we need to save the item first to get its ID
            const newItemId = await addItem(payload);

            // Then establish bidirectional pairing links
            if (payload.pairings && (payload.pairings.good.length > 0 || payload.pairings.bad.length > 0)) {
              // Add good pairings
              for (const targetId of payload.pairings.good) {
                await addPairing(newItemId, targetId, 'good');
              }

              // Add bad pairings
              for (const targetId of payload.pairings.bad) {
                await addPairing(newItemId, targetId, 'bad');
              }
            }

            setStatus('Item added!');
          }
          setTimeout(() => { closeEditor(); refreshList(); }, 800);
        }catch(e){ setStatus('Error: ' + e.message); }
      };
      [el('scannerModal'), el('detailsModal'), el('editorModal')].forEach(modal => {
        modal.onclick = (e) => { if(e.target === modal){ modal.classList.remove('active'); if(modal === el('scannerModal')) stopScan(); } };
      });
      el('closePhotoBtn').onclick = () => el('photoModal').classList.remove('active');
      el('photoModal').onclick = (e) => { if(e.target === el('photoModal') || e.target === el('closePhotoBtn')) el('photoModal').classList.remove('active'); };
      await refreshList();
      enhanceSelectInteractivity(document);
      if('serviceWorker' in navigator){ window.addEventListener('load', () => navigator.serviceWorker.register('./sw.js')); }
    }
    initApp();
</script>
</body>
</html>
