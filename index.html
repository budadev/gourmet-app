<!-- =============================
File: index.html
Purpose: GourmetApp — installable PWA that scans barcodes, stores items in local IndexedDB, supports search, optional lookup via Open Food Facts
How to use:
 1) Save files as shown below (index.html, sw.js, manifest.webmanifest).
 2) Serve over HTTPS (required for camera). Any static host works (Cloudflare Pages, GitHub Pages, Netlify, simple HTTPS server).
 3) On iPhone: open in Safari → Share → Add to Home Screen. First launch will ask for camera permission when scanning.
================================ -->
<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>GourmetApp</title>
    <meta name="theme-color" content="#111827" />
    <link rel="manifest" href="./manifest.webmanifest" />
    <link rel="apple-touch-icon" href="icons/icon-192.png" />
    <style>
        :root{--bg:#0b1220;--card:#111827;--muted:#9ca3af;--text:#e5e7eb;--acc:#34d399}
        *{box-sizing:border-box}body{margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto}
        header{position:sticky;top:0;background:linear-gradient(180deg,#0b1220,#0b1220cc);backdrop-filter:blur(8px);padding:12px 16px;border-bottom:1px solid #1f2937;z-index:100}
        h1{margin:0 0 12px 0;font-size:18px;letter-spacing:.5px}
        main{max-width:860px;margin:0 auto;padding:16px;padding-bottom:80px}
        .row{display:flex;gap:8px;flex-wrap:wrap}
        .btn{appearance:none;border:1px solid #374151;background:#111827;color:#e5e7eb;border-radius:12px;padding:10px 14px;font-weight:600;cursor:pointer}
        .btn.primary{background:#10b981;border-color:#10b981;color:#06281f}
        .btn:disabled{opacity:0.5;cursor:not-allowed}
        .card{background:var(--card);border:1px solid #1f2937;border-radius:16px;padding:14px;margin-bottom:12px}
        input,select,textarea{width:100%;background:#0b1220;border:1px solid #374151;border-radius:10px;color:#e5e7eb;padding:10px}
        label{font-size:12px;color:var(--muted);display:block;margin-bottom:4px}
        .grid{display:grid;grid-template-columns:1fr;gap:12px}
        @media(min-width:700px){.grid{grid-template-columns:1fr 1fr}}
        .list{display:grid;gap:10px}
        .item{background:#0f172a;border:1px solid #1f2937;border-radius:12px;padding:12px;cursor:pointer;transition:all 0.2s}
        .item:hover{border-color:#374151;background:#1a1f2e}
        .item.selected{border-color:#10b981;background:#0d3d2e}
        .muted{color:var(--muted);font-size:14px}
        video{width:100%;border-radius:16px;background:#000}
        .badge{display:inline-block;padding:4px 10px;border-radius:999px;background:#0b3c2f;color:#a7f3d0;border:1px solid #065f46;font-size:14px;font-weight:600}

        /* Search bar with barcode icon */
        .search-wrapper{position:relative;width:100%}
        .search-wrapper input{padding-right:50px}
        .search-wrapper .barcode-btn{position:absolute;right:4px;top:50%;transform:translateY(-50%);background:transparent;border:none;color:var(--acc);font-size:24px;cursor:pointer;padding:8px;border-radius:8px;display:flex;align-items:center;justify-content:center}
        .search-wrapper .barcode-btn:hover{background:#1f2937}

        /* Floating add button */
        .fab{position:fixed;bottom:24px;right:24px;width:56px;height:56px;border-radius:50%;background:#10b981;border:none;color:#06281f;font-size:32px;box-shadow:0 4px 12px rgba(16,185,129,0.4);cursor:pointer;display:flex;align-items:center;justify-content:center;z-index:1000;transition:transform 0.2s}
        .fab:hover{transform:scale(1.1)}
        .fab:active{transform:scale(0.95)}

        /* Modal/overlay styles */
        .modal{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);z-index:2000;display:none;overflow-y:auto;padding:16px}
        .modal.active{display:flex;align-items:flex-start;justify-content:center}
        .modal-content{background:var(--card);border:1px solid #1f2937;border-radius:16px;padding:20px;max-width:600px;width:100%;margin-top:20px}
        .modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:16px}
        .modal-header h2{margin:0;font-size:20px}
        .close-btn{background:transparent;border:none;color:var(--muted);font-size:28px;cursor:pointer;padding:0;width:32px;height:32px;display:flex;align-items:center;justify-content:center;border-radius:8px}
        .close-btn:hover{background:#1f2937;color:var(--text)}

        /* Item details */
        .detail-section{margin-top:16px}
        .detail-row{display:flex;justify-content:space-between;margin-bottom:12px;padding-bottom:12px;border-bottom:1px solid #1f2937}
        .detail-row:last-child{border-bottom:none}
        .detail-label{color:var(--muted);font-size:13px}
        .detail-value{font-weight:600}

        .empty-state{text-align:center;padding:40px 20px;color:var(--muted)}

        /* Star rating */
        .star-rating{display:flex;gap:4px;align-items:center}
        .star{font-size:28px;cursor:pointer;color:#374151;transition:color 0.2s;user-select:none}
        .star.filled{color:#fbbf24}
        .star.half{position:relative;color:#374151}
        .star.half::before{content:'★';position:absolute;left:0;top:0;color:#fbbf24;overflow:hidden;width:50%}
        .star-rating-display{display:flex;gap:2px;align-items:center}
        .star-rating-display .star{font-size:20px;cursor:default}

        /* Dynamic fields */
        .field-group{margin-bottom:12px}
        .field-group label{display:block;margin-bottom:4px}
    </style>
</head>
<body>
<header>
    <h1>🥘 GourmetApp</h1>
    <div class="search-wrapper">
        <input id="searchInput" type="text" placeholder="Search by name, notes, or barcode…"/>
        <button class="barcode-btn" id="barcodeScanBtn" title="Scan barcode">📷</button>
    </div>
</header>

<main>
    <!-- Scanner section (shown in modal) -->
    <div id="scannerModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Scan Barcode</h2>
                <button class="close-btn" id="closeScannerBtn">×</button>
            </div>
            <video id="preview" playsinline></video>
            <div class="muted" style="margin-top:8px;text-align:center" id="scanHint">Point your camera at a barcode (EAN/UPC/Code128).</div>
        </div>
    </div>

    <!-- Item details modal -->
    <div id="detailsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Item Details</h2>
                <button class="close-btn" id="closeDetailsBtn">×</button>
            </div>
            <div id="detailsContent"></div>
        </div>
    </div>

    <!-- Editor modal -->
    <div id="editorModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="editorTitle">Add Item</h2>
                <button class="close-btn" id="closeEditorBtn">×</button>
            </div>
            <div id="editorFields">
                <!-- Dynamic fields will be generated here -->
            </div>
            <div class="row" style="margin-top:16px">
                <button class="btn primary" id="saveBtn">Save</button>
                <button class="btn" id="cancelEditorBtn">Cancel</button>
            </div>
            <div class="muted" style="margin-top:8px" id="status"></div>
        </div>
    </div>

    <!-- Items list -->
    <div id="results" class="list"></div>
</main>

<!-- Floating add button -->
<button class="fab" id="fabBtn" title="Add new item">+</button>

<!-- ZXing barcode scanner via ESM build -->
<script type="module">
    // ====== Load item types configuration ======
    let ITEM_TYPES_CONFIG = {};

    // ====== Simple IndexedDB wrapper (no external deps) ======
    const DB_NAME = 'gourmetapp-db';
    const STORE = 'items';
    const dbp = new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, 1);
      req.onupgradeneeded = () => {
        const db = req.result;
        const store = db.createObjectStore(STORE, { keyPath: 'id', autoIncrement: true });
        store.createIndex('by_barcode', 'barcode', { unique: false });
        store.createIndex('by_name', 'name', { unique: false });
        store.createIndex('by_type', 'type', { unique: false });
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });

    async function tx(mode = 'readonly') {
      const db = await dbp; return db.transaction(STORE, mode).objectStore(STORE);
    }
    async function addItem(item){ const store = await tx('readwrite'); return new Promise((res,rej)=>{ const r=store.add({...item, createdAt: Date.now(), updatedAt: Date.now()}); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
    async function updateItem(id, patch){ const store = await tx('readwrite'); const get=store.get(id); return new Promise((res,rej)=>{ get.onsuccess=()=>{ const cur=get.result; if(!cur) return rej(new Error('Not found')); const put=store.put({...cur, ...patch, updatedAt: Date.now()}); put.onsuccess=()=>res(put.result); put.onerror=()=>rej(put.error); }; get.onerror=()=>rej(get.error); }); }
    async function deleteItem(id){ const store = await tx('readwrite'); return new Promise((res,rej)=>{ const r=store.delete(id); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error); }); }
    async function getItem(id){
      const store = await tx('readonly');
      return new Promise((res,rej)=>{ const r=store.get(id); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); });
    }
    async function listAll(){
      const store = await tx('readonly');
      return new Promise((res)=>{ const out=[]; const c=store.openCursor(); c.onsuccess=()=>{ const cur=c.result; if(cur){ out.push(cur.value); cur.continue(); } else res(out); }; });
    }
    async function findByBarcode(code){
      const store = await tx('readonly');
      return new Promise((res)=>{ const idx=store.index('by_barcode'); const r=idx.getAll(code); r.onsuccess=()=>res(r.result||[]); });
    }
    async function searchByText(q){
      q=(q||'').toLowerCase();
      const all = await listAll();
      if(!q) return all;
      return all.filter(it => (it.name||'').toLowerCase().includes(q) || (it.notes||'').toLowerCase().includes(q) || (it.barcode||'').includes(q));
    }

    // ====== Star Rating Helper ======
    function renderStars(rating, interactive = false) {
      const stars = [];
      const fullStars = Math.floor(rating);
      const hasHalf = rating % 1 >= 0.5;

      for (let i = 1; i <= 5; i++) {
        if (i <= fullStars) {
          stars.push(`<span class="star filled" data-value="${i}">★</span>`);
        } else if (i === fullStars + 1 && hasHalf) {
          stars.push(`<span class="star half" data-value="${i - 0.5}">★</span>`);
        } else {
          stars.push(`<span class="star" data-value="${i}">★</span>`);
        }
      }

      const className = interactive ? 'star-rating' : 'star-rating-display';
      return `<div class="${className}">${stars.join('')}</div>`;
    }

    function setupStarRating(container, initialValue = 0) {
      let currentRating = initialValue;
      const stars = container.querySelectorAll('.star');

      stars.forEach((star, index) => {
        // Click on left half = half star, click on right half = full star
        star.addEventListener('click', (e) => {
          const rect = star.getBoundingClientRect();
          const clickX = e.clientX - rect.left;
          const starWidth = rect.width;
          const isLeftHalf = clickX < starWidth / 2;

          let value;
          if (isLeftHalf) {
            value = index + 0.5;
          } else {
            value = index + 1;
          }

          currentRating = value;
          updateStars(value);
        });

        star.addEventListener('mousemove', (e) => {
          const rect = star.getBoundingClientRect();
          const clickX = e.clientX - rect.left;
          const starWidth = rect.width;
          const isLeftHalf = clickX < starWidth / 2;

          let value;
          if (isLeftHalf) {
            value = index + 0.5;
          } else {
            value = index + 1;
          }
          updateStars(value);
        });
      });

      container.addEventListener('mouseleave', () => {
        updateStars(currentRating);
      });

      function updateStars(rating) {
        const fullStars = Math.floor(rating);
        const hasHalf = rating % 1 >= 0.5;

        stars.forEach((star, idx) => {
          star.classList.remove('filled', 'half');
          if (idx < fullStars) {
            star.classList.add('filled');
          } else if (idx === fullStars && hasHalf) {
            star.classList.add('half');
          }
        });
      }

      updateStars(currentRating);

      return {
        getValue: () => currentRating,
        setValue: (value) => {
          currentRating = value;
          updateStars(value);
        }
      };
    }

    // ====== UI helpers ======
    const el = id => document.getElementById(id);
    const resultsEl = el('results');
    let currentEditingId = null;
    let starRatingController = null;

    function sortByRating(items){
      return items.sort((a, b) => (Number(b.rating)||0) - (Number(a.rating)||0));
    }

    function getTypeInfo(typeKey) {
      return ITEM_TYPES_CONFIG[typeKey] || { label: typeKey, icon: '📦', fields: [] };
    }

    function renderList(items){
      const sorted = sortByRating([...items]);
      if(sorted.length === 0){
        resultsEl.innerHTML = '<div class="empty-state">No items found. Tap the + button to add your first item!</div>';
        return;
      }
      resultsEl.innerHTML = sorted.map(it => {
        const typeInfo = getTypeInfo(it.type);
        return `
        <div class="item" data-id="${it.id}">
          <div class="row" style="justify-content:space-between;align-items:center">
            <div style="flex:1">
              <div style="font-weight:700;font-size:16px">${typeInfo.icon} ${escapeHtml(it.name||'Unnamed')}</div>
              <div class="muted" style="font-size:12px;margin-top:4px">${typeInfo.label}</div>
            </div>
            <div>${renderStars(Number(it.rating)||0, false)}</div>
          </div>
        </div>`;
      }).join('');

      // Bind click events to show details
      resultsEl.querySelectorAll('.item').forEach(itemEl => {
        itemEl.onclick = () => {
          const id = Number(itemEl.getAttribute('data-id'));
          showItemDetails(id);
        };
      });
    }

    async function showItemDetails(id){
      const item = await getItem(id);
      if(!item) return;

      const typeInfo = getTypeInfo(item.type);
      const detailsContent = el('detailsContent');

      let fieldsHTML = `
        <div class="detail-row">
          <div class="detail-label">Name</div>
          <div class="detail-value">${escapeHtml(item.name||'Unnamed')}</div>
        </div>
        <div class="detail-row">
          <div class="detail-label">Type</div>
          <div class="detail-value">${typeInfo.icon} ${escapeHtml(typeInfo.label)}</div>
        </div>
        <div class="detail-row">
          <div class="detail-label">Rating</div>
          <div class="detail-value">${renderStars(Number(item.rating)||0, false)}</div>
        </div>
        ${item.barcode ? `<div class="detail-row">
          <div class="detail-label">Barcode</div>
          <div class="detail-value">${escapeHtml(item.barcode)}</div>
        </div>` : ''}
      `;

      // Add dynamic fields
      typeInfo.fields.forEach(field => {
        if (item[field.name]) {
          fieldsHTML += `
            <div class="detail-row">
              <div class="detail-label">${escapeHtml(field.label)}</div>
              <div class="detail-value">${escapeHtml(String(item[field.name]))}</div>
            </div>
          `;
        }
      });

      fieldsHTML += `
        ${item.notes ? `<div class="detail-row">
          <div class="detail-label">Notes</div>
          <div class="detail-value">${escapeHtml(item.notes)}</div>
        </div>` : ''}
        <div class="detail-row">
          <div class="detail-label">Last Updated</div>
          <div class="detail-value">${new Date(item.updatedAt||Date.now()).toLocaleString()}</div>
        </div>
      `;

      detailsContent.innerHTML = `
        <div class="detail-section">${fieldsHTML}</div>
        <div class="row" style="margin-top:16px">
          <button class="btn primary" id="editDetailsBtn">Edit</button>
          <button class="btn" id="deleteDetailsBtn">Delete</button>
        </div>
      `;

      el('detailsModal').classList.add('active');

      // Bind edit button
      el('editDetailsBtn').onclick = () => {
        el('detailsModal').classList.remove('active');
        openEditor(item);
      };

      // Bind delete button
      el('deleteDetailsBtn').onclick = async () => {
        if(confirm(`Delete "${item.name}"?`)){
          await deleteItem(id);
          el('detailsModal').classList.remove('active');
          await refreshList();
          setStatus('Item deleted.');
        }
      };
    }

    function renderEditorFields(selectedType, itemData = {}) {
      const typeInfo = getTypeInfo(selectedType);
      const editorFields = el('editorFields');

      console.log('Rendering editor for type:', selectedType);
      console.log('Type info:', typeInfo);
      console.log('Fields count:', typeInfo.fields.length);

      let html = '<div class="grid">';

      // Type selector
      html += '<div class="field-group"><label>Type *</label><select id="typeSelect">';
      Object.keys(ITEM_TYPES_CONFIG).forEach(key => {
        const cfg = ITEM_TYPES_CONFIG[key];
        html += `<option value="${key}" ${key === selectedType ? 'selected' : ''}>${cfg.icon} ${cfg.label}</option>`;
      });
      html += '</select></div>';

      // Name (always)
      html += `<div class="field-group"><label>Name *</label><input id="nameInput" placeholder="e.g., Cabernet Sauvignon" value="${escapeHtml(itemData.name||'')}"/></div>`;

      // Barcode (always)
      html += `<div class="field-group"><label>Barcode (optional)</label><input id="barcodeInput" placeholder="e.g., 5991234567890" value="${escapeHtml(itemData.barcode||'')}"/></div>`;

      // Rating (always) - full width
      html += `<div class="field-group" style="grid-column:1/-1"><label>Rating *</label><div id="ratingContainer">${renderStars(Number(itemData.rating)||0, true)}</div></div>`;

      // Dynamic fields based on type
      console.log('Adding dynamic fields...');
      typeInfo.fields.forEach(field => {
        console.log('Adding field:', field.name, field.label, field.type);
        html += '<div class="field-group">';
        html += `<label>${escapeHtml(field.label)}</label>`;

        if (field.type === 'enum') {
          html += `<select id="field_${field.name}">`;
          html += '<option value="">-- Select --</option>';
          field.options.forEach(opt => {
            const selected = itemData[field.name] === opt ? 'selected' : '';
            html += `<option value="${escapeHtml(opt)}" ${selected}>${escapeHtml(opt)}</option>`;
          });
          html += '</select>';
        } else if (field.type === 'number') {
          html += `<input type="number" id="field_${field.name}" value="${itemData[field.name]||''}" placeholder="e.g., 2015"/>`;
        } else {
          html += `<input type="text" id="field_${field.name}" value="${escapeHtml(itemData[field.name]||'')}" placeholder="Enter ${field.label.toLowerCase()}"/>`;
        }

        html += '</div>';
      });

      // Notes (always) - full width
      html += `<div class="field-group" style="grid-column:1/-1"><label>Notes</label><textarea id="notesInput" rows="4" placeholder="Tasting notes, where you had it, etc.">${escapeHtml(itemData.notes||'')}</textarea></div>`;

      html += '</div>';

      console.log('Generated HTML length:', html.length);
      editorFields.innerHTML = html;

      // Setup star rating
      const ratingContainer = el('ratingContainer');
      starRatingController = setupStarRating(ratingContainer, Number(itemData.rating)||0);

      // Handle type change
      el('typeSelect').onchange = (e) => {
        const currentData = collectFormData();
        renderEditorFields(e.target.value, currentData);
      };
    }

    function collectFormData() {
      const selectedType = el('typeSelect')?.value || Object.keys(ITEM_TYPES_CONFIG)[0];
      const typeInfo = getTypeInfo(selectedType);

      const data = {
        type: selectedType,
        name: el('nameInput')?.value?.trim() || '',
        barcode: el('barcodeInput')?.value?.trim() || '',
        rating: starRatingController?.getValue() || 0,
        notes: el('notesInput')?.value?.trim() || ''
      };

      // Collect dynamic fields
      typeInfo.fields.forEach(field => {
        const fieldEl = el(`field_${field.name}`);
        if (fieldEl && fieldEl.value) {
          data[field.name] = field.type === 'number' ? Number(fieldEl.value) : fieldEl.value;
        }
      });

      return data;
    }

    function openEditor(item = null){
      if(item){
        el('editorTitle').textContent = 'Edit Item';
        currentEditingId = item.id;
        renderEditorFields(item.type || Object.keys(ITEM_TYPES_CONFIG)[0], item);
      } else {
        el('editorTitle').textContent = 'Add Item';
        currentEditingId = null;
        renderEditorFields(Object.keys(ITEM_TYPES_CONFIG)[0], {});
      }
      el('editorModal').classList.add('active');
      setStatus('');
    }

    function closeEditor(){
      el('editorModal').classList.remove('active');
      currentEditingId = null;
      starRatingController = null;
    }

    async function refreshList(){
      const query = el('searchInput').value.trim();
      const items = await searchByText(query);
      renderList(items);
    }

    function setStatus(msg){ el('status').textContent = msg; }
    function escapeHtml(s){ return (s||'').replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[m])); }

    // ====== External lookup (Open Food Facts) ======
    async function lookupByBarcodeOFF(code){
      try{
        const r = await fetch(`https://world.openfoodfacts.org/api/v0/product/${encodeURIComponent(code)}.json`);
        const j = await r.json();
        if(j && j.status === 1){
          const p = j.product||{};
          return {
            name: p.product_name || p.generic_name || 'Unknown product',
            type: Object.keys(ITEM_TYPES_CONFIG)[0] || 'wine',
            barcode: code,
            rating: 0,
            notes: p.brands ? `Brand: ${p.brands}` : ''
          };
        }
      }catch(e){/* ignore */}
      return null;
    }

    // ====== Barcode scanner ======
    import { BrowserMultiFormatReader } from 'https://cdn.jsdelivr.net/npm/@zxing/library@0.20.0/+esm';
    const codeReader = new BrowserMultiFormatReader();
    let currentStream = null;

    async function startScan(){
      const vid = el('preview');
      el('scannerModal').classList.add('active');
      try{
        const devices = await BrowserMultiFormatReader.listVideoInputDevices();
        const deviceId = devices?.[0]?.deviceId;
        currentStream = await navigator.mediaDevices.getUserMedia({ video: { deviceId, facingMode: { ideal: 'environment' } } });
        vid.srcObject = currentStream; await vid.play();
        codeReader.decodeFromVideoDevice(deviceId || undefined, vid, async (res, err) => {
          if(res){
            const code = res.getText();
            el('scanHint').textContent = `Scanned: ${code}`;
            stopScan();

            // Search for items with this barcode
            const items = await findByBarcode(code);
            if(items && items.length > 0){
              // Show results
              el('searchInput').value = code;
              renderList(items);
            } else {
              // No match found - offer to add new item
              el('searchInput').value = code;
              renderList([]);

              // Try to fetch from Open Food Facts
              const fetched = await lookupByBarcodeOFF(code);
              if(fetched && confirm(`Barcode not found in your collection. Found "${fetched.name}" in Open Food Facts. Add it?`)){
                openEditor({...fetched, barcode: code});
              } else if(!fetched) {
                if(confirm('Barcode not found. Add new item?')){
                  openEditor({barcode: code});
                }
              }
            }
          }
        });
      }catch(e){
        el('scanHint').textContent = 'Camera error: '+ e.message;
        setTimeout(stopScan, 3000);
      }
    }

    function stopScan(){
      try{ codeReader.reset(); }catch(_){}
      if(currentStream){ currentStream.getTracks().forEach(t=>t.stop()); currentStream = null; }
      el('scannerModal').classList.remove('active');
      el('scanHint').textContent = 'Point your camera at a barcode (EAN/UPC/Code128).';
    }

    // ====== App Initialization ======
    async function initApp(){
      // Load item types configuration
      try{
        const response = await fetch('./item-types-config.json');
        ITEM_TYPES_CONFIG = await response.json();
        console.log('Loaded item types:', Object.keys(ITEM_TYPES_CONFIG));
      }catch(e){
        console.error('Could not load item types config:', e.message);
        // Fallback to default types
        ITEM_TYPES_CONFIG = {
          wine: { label: 'Wine', icon: '🍷', fields: [] },
          cheese: { label: 'Cheese', icon: '🧀', fields: [] },
          olives: { label: 'Olives', icon: '🫒', fields: [] }
        };
      }

      // ====== Event wiring ======

      // Search functionality
      el('searchInput').oninput = async () => {
        await refreshList();
      };

      // Barcode scan button
      el('barcodeScanBtn').onclick = startScan;
      el('closeScannerBtn').onclick = stopScan;

      // Close details modal
      el('closeDetailsBtn').onclick = () => {
        el('detailsModal').classList.remove('active');
      };

      // FAB - open add item form
      el('fabBtn').onclick = () => {
        openEditor();
      };

      // Editor controls
      el('closeEditorBtn').onclick = closeEditor;
      el('cancelEditorBtn').onclick = closeEditor;

      el('saveBtn').onclick = async ()=>{
        const payload = collectFormData();

        if(!payload.name){
          setStatus('Please enter a name.');
          return;
        }

        try{
          if(currentEditingId){
            await updateItem(currentEditingId, payload);
            setStatus('Item updated!');
          }else{
            await addItem(payload);
            setStatus('Item added!');
          }
          setTimeout(() => {
            closeEditor();
            refreshList();
          }, 800);
        }catch(e){
          setStatus('Error: ' + e.message);
        }
      };

      // Close modals on background click
      [el('scannerModal'), el('detailsModal'), el('editorModal')].forEach(modal => {
        modal.onclick = (e) => {
          if(e.target === modal){
            modal.classList.remove('active');
            if(modal === el('scannerModal')) stopScan();
          }
        };
      });

      // Initial load
      await refreshList();

      // PWA Service Worker
      if('serviceWorker' in navigator){
        window.addEventListener('load', ()=> navigator.serviceWorker.register('./sw.js'));
      }
    }

    // Start the app
    initApp();
</script>
</body>
</html>
